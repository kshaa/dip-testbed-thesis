\section{Platformas lietojamība un uzturēšana}
\label{sec:maintenance}

Darba izstrādes laikā tika pacelti apsvērumi par šādas platformas uzturamību un
lietojamību, kas apskatīti un aprakstīti šajā nodaļā. J - jautājums, A -
atbilde.

J. Cik sarežģīti laboratorijas īpašniekam ir pieslēgt savu laboratoriju
platformai?

A. Ir nepieciešama papildus aparatūra laboratorijā, kas funkcionēs kā
komunikācijas starpnieks starp platformu un aparatūru, jeb ir nepieciešams
aģenta dators vai mikrokontrolieris. Aģentu nepieciešams administrēt, tajā
jāuzstāda aparatūras pārvaldības programmatūra, ko parasti nodrošina aparatūras
ražotāji. Aģentā nepieciešams uzstādīt platformas komandu rindas aģenta rīku.
Lai optimizētu šo administrēšanas procesu tehniski ir iespējams izstrādāt
Ansible, Chef vai citu automatizācijas risinājumu skriptus, lai automātiski
nokonfigurētu aģenta sistēmu. Papildus, ja ir aģenti nepieciešami ir daudz,
tehniski Raspberry mikrokontroliera gadījumā ir iespējams izstrādāt sistēmas
attēla kopiju, ko var pārkopēt citā SD kartē, ko var ievietot nākamajā Raspberry
mikrokontrolierī, tādējādi vienkāršojot aģentu uzstādīšanas procesu. Darba
ietvaros šīs divas optimizācijas nav mēģināts izstrādāt laika ierobežojumu dēļ.

J. Cik sarežģīti platformas autoram ir izstrādāt jaunu platformas versiju?

A. Platformas pirmkoda kompilēšana ir automatizēta. Pirmkoda repozitorijā ir
fails \lstinline!build.sh!, kas automātiski sakompilē platformas servera Scala
pirmkodu ar \lstinline!sbt! rīku, automātiski sakompilē platformas aģenta un
klienta komandu rindas rīkus \lstinline!AMD64! un \lstinline!ARM64! procesoru
arhitektūrām (\lstinline!ARM64! nepieciešams, lai darbinātu aģentu Raspberry Pi
mikrokontrolierī vai Apple datorā ar M1 procesoru) un ar \lstinline!pip! rīku un
\lstinline!docker buildx!, kas atbalsta multi-platformu kompilāciju,
\cite{DockerBuildx}. Lai autora darbs būtu vēl vieglāks šo visu varētu
automatizēt kādā nepārtrauktās integrācijas platformā, piem. Jenkins, Drone CI,
Concourse CI, Hydra CI, u.c..

J. Cik sarežģīti platformas izstrādātājam ir sākt lietot platformu?

A. Lai sāktu izmantot platformā pieejamo aparatūru, ir izstrādāts skripts, lai
automātiski datorā ieinstalētu platformas komandu rindas klienta rīku. Tekstā
\ref{lst:setup} redzams, ka no klienta ieinstalēšanas līdz programmaparatūras
augšupielādei un lietošanai ir tikai trīs komandas, neskaitot lietotāja un tā
tiesību izveidošanu, ko tipiski darītu laboratorijas vai platformas īpašnieks.

Papildus ir vērts pieminēt, ka pieejamā platforma tika atrādīta maģistra
studentiem kursā DatZ3074 un saņēma pozitīvas atsauksmes, ka to būtu iespējams
izmantot, lai piemēram projektētu kādu spēli tranzistoru loģikā vai projektētu
galīgus determinētus automātus, utml., kā arī tika saņemti ieteikumi kā
platforma varētu tikt uzlabota ar jaunu funkcionalitāti nākotnē, piem. lai
abstrahētu vairākas \gls{fpga} attīstītājrīku iekārtas vai lai veiktu
paralelizētu datu apstrādi ar ierīču klasteriem. 

\begin{lstlisting}[caption={Platformas klienta lietošanas uzsākšana},label={lst:setup},captionpos=b]
curl -L https://github.com/kshaa/dip-test[...]install.sh | bash
dip_client session-auth -u <username> -p <password>
dip_client quick-run -f firmware.bit -b ${BOARD_UUID}
\end{lstlisting}

\section{Programmaparatūras testēšana}
\label{sec:testing}

Lai gan platformā iespējams augšupielādēt un attālināti mijiedarboties ar
programmaparatūru, tās testēšana nebūt nav triviāla.

Viens variants ir testēt programmaparatūru manuāli - attālināti augšupielādēt to
attīstītājrīka aparatūrā, uzsākt virtuālās saskarnes sesiju, mijiedarboties un
secināt vai aparatūra darbojas kā paredzēts. Šis variants ir pilnīgi pietiekams
maza izmēra projektiem, kuriem nav stingru laika ierobežojumu. Šis arī ir veids
kā tika testēta platformas demo programmaparatūra un tātad šis testēšanas veids
ir pieejams platformā.

Otrs variants ir pirms programmaparatūras augšupielādes aparatūrā, veikt tās
programmatisku simulāciju, ko nodrošina tādi rīki kā \lstinline!iverilog! vai
grafiskā izstrādes vide \lstinline!Xilinx ISE!. Šis ir viens no
svarīgākajiem izstrādātāja instrumentiem, kas arī tika izmantots testējot demo
programmaparatūru un ir izmantojams platformas ietvaros, lai gan tehniski ir
ārpus-platformas rīks.

Trešais variants ir testēt programmaparatūras darbību programmatiski.Un pat šim
variantam ir divi veidi - testēt reāllaikā un testēt post-factum. 

Platformas ietvaros tika izstrādāta virtuālā saskarne \lstinline!minosrequest!,
kas ļauj definēt laikus, kad iesūtīt saskarnē ziņas, un kas ieraksta visas
ienākošās un izejošās ziņas JSON formātā. Ar šo saskarni ir iespējams realizēt
post-factum darbības testēšanu veicot datu jeb ziņu analīzi jebkurā
programmēšanas valodā, kas spēj parsēt JSON datus. Kā piemēru analizējamiem
datiem, var skatīt JSON ierakstu pielikumā \ref{att:minosrequest}.

Lai testētu programmaparatūras darbību reāllaikā ir dažādas realizācijas
iespējas. Viens variants ir skaidri dokumentēt platformas seriālās komunikācijas
WebSocket API un izmantoto protokolu, kas ļautu jebkurā programmēšanas valodā
viegli attālināti pieslēgties aparatūrai un definēt jebkāda veida mijiedarbību
vai papildus virtuālu saskarni, vai testus, u.t.t. Šī ir laba ideja, kas nav
realizēta darba ietvaros laika ierobežojumu dēļ.

Iepriekšminētajai pieejai gan ir viens mīnuss, kas ir, ka izstrādātājam ir vai
nu jābūt ieslēgtam laptopam vai arī jāuztur sava infrastruktūra, lai veiktu
ilgtermiņa (stundas vai dienas) testus. Potenciāls risinājums šim ir iestrādāt
platformas serverī \gls{wasm} atbalstu un ļaut iesūtīt WASM programmatūru, kas
darbotos platformā, saņemtu ziņas, sūtītu atpakaļ ziņas, rakstītu žurnāla datus,
secinātu vai apratūra darbojas korekti. Šādai pieejai arī būtu pluss, ka visi
izvadītie testa dati būtu standartizēti un pieejami platformā. Darba ietvaros
tika veikti eksperimenti un tika secināts, ka Scala programmēšanas valodā ir
WASM virtuālmašīnas darbināšanas atbalsts, taču laika ierobežojumu dēļ, ideja
netika tālāk izpētīta.
